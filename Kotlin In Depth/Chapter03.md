## 1. 식이 본문인 함수란 무엇인가?
return 키워드와 블록을 만드는 중괄호({})를 생략하는 단일 식 형태의 함수로, 컴파일러가 표현식의 타입을 추론할 수 있기 때문에 명시적인 반환 타입을 생략해도 된다.

### 블록이 본문인 함수 대신 식이 본문인 함수를 쓰면 어떤 경우에 더 좋을까?
로직이 단순하고 결과를 바로 반환하는 경우 식이 본문인 함수를 쓰는게 더 좋다.

블록이 본문인 함수는 복잡한 연산이나 여러 단계의 처리가 필요한 경우에 더 적절하다.

## 2. 디폴트 파라미터와 함수 오버로딩 중 어느 쪽을 써야 할지 어떻게 결정할 수 있을까?
미리 정해진 디폴트 값을 사용할 수 있게 하고자 메서드를 오버로딩해야 하는 경우 디폴트 파라미터를 사용하고, 파라미터의 개수나 타입에 따라 다른 로직을 수행해야 하는 경우 오버로딩을 사용하는 것이 좋다.

## 3. 이름 붙은 인자를 사용할 경우의 장단점은 무엇인가?
**장점** : 인자의 순서를 고려하지 않아도 된다.

- **WHY)** : 인자의 위치가 아니라 파라미터의 이름을 명시하여 인자를 전달하는 방식이기 때문이다.

**단점** : 위치 기반 인자와 이름 붙은 인자를 함께 사용한 경우 원래 인자가 들어가야 할 위치에 이름 붙은 인자를 지정해야 정상 처리되며, 그렇지 않은 경우 위치 기반 인자의 타입이 어긋나거나 이미 할당된 인자를 재할당하기 때문에 컴파일 오류가 발생한다.

## 4. 인자 개수가 가변적인 함수를 정의하는 방법은 무엇인가?
파라미터 정의 앞에 `vararg` 변경자(modifier)를 붙여 배열 타입으로 넘기거나 스프레드(spread) 연산자인 `*`를 사용하여 배열을 가변 인자 대신 넘길 수 있다.

### 코틀린과 자바에서 vararg 함수는 어떻게 다른가?
자바에서는 vararg 파라미터가 항상 마지막 파라미터이지만, 코틀린에서는 vararg 파라미터가 함수 파라미터 중 어디에나 올 수 있다. 다만, vararg 파라미터 이후의 파라미터는 이름 붙은 인자로만 전달할 수 있다.

## 5. Unit과 Nothing 타입을 어디에 사용하는가? (이들을 자바의 void와 비교해 설명하라.)
Unit은 함수가 의미 있는 반환값을 돌려주지 않을 때 사용한다.

Nothing은 프로그램의 순차적 제어 흐름이 그 부분에서 끝나되 어떤 잘 정의된 값에 도달하지 못할 때 사용한다.

Unit은 자바 void에 해당하는 코틀린 타입으로, Nothing과 달리 한 가지 인스턴스가 존재하는데, 이 인스턴스는 보통 유용한 값이 없다는 사실을 표현한다. 반면 Nothing은 아예 값이 없다는 사실을 표현한다.

### Nothing이나 Unit이 타입인 함수를 정의해 사용할 수 있는가?
Nothing 타입은 return의 경우 이 문장을 둘러싼 함수가 끝난다. 모든 코틀린 타입의 하위 타입으로 간주되기 때문에 식이 필요한 위치에 return을 사용해도 타입 오류가 발생하지 않는다.
- `return e`의 e 값은 return 식의 값이 아니라 함수의 반환값이라는 점에 유의하자. return 식 자체는 아무 값이 없고 Nothing 타입에 속한다.

Unit 타입은 함수에서 결과가 항상 Unit으로 동일하기 때문에 결과를 지정하는 return 문을 쓸 필요가 없다. 하지만 함수 본문의 끝에 도달하기 전에 함수 실행을 마치려면 return 문을 사용해 함수를 끝내야 한다.

## 6. return 0과 같은 코드의 의미를 설명해보라.
해당 함수가 정수 0을 반환하는 것으로, 해당 함수의 반환 타입이 Int일 때 사용된다. 보통 함수의 반환 유형을 명시적으로 선언하고, 반환값이 필요 없는 경우에는 Unit을 사용한다. 따라서 return 0은 주로 함수가 특정 결과를 반환하는 상황에서 사용된다.

- 함수가 어떤 계산을 수행하고 그 결과를 반환하는데, 그 결과가 0이면 성공적으로 완료되었음을 나타낼 때 사용할 수 있다.
```kotlin
fun exampleFunction(): Int {
    // 어떤 계산을 수행한 후, 결과가 0이면 성공적으로 완료되었음을 나타냄
    return 0
}

fun main() {
    val result = exampleFunction()

    if (result == 0) {
        println("함수가 성공적으로 실행되었습니다.")
    } else {
        println("함수 실행 중 오류가 발생했습니다.")
    }
}
```

### 이런 코드가 올바르지만 불필요한 중복이 있는 것으로 여겨지는 이유는 무엇인가?
함수의 성공 또는 실패를 나타내는 값이 0 하나로 특정되어 있기 때문이다. 즉, 함수의 성공 여부를 판단하는 데 사용되는 값이 항상 0이라면, 매번 이 값을 확인하는 코드가 중복된 느낌을 줄 수 있다.

코틀린에서는 일반적으로 함수가 성공적으로 수행되면 Unit을 반환하거나, 실패한 경우 예외를 던지는 등의 방식을 사용한다. 이로써 성공 또는 실패를 판단하는 코드에서 중복을 최소화하고 가독성을 높일 수 있다.
```kotlin
fun exampleFunction(): Unit {
    // 어떤 계산을 수행
    // 성공적으로 완료되면 아무것도 반환하지 않음 (Unit)
}

fun main() {
    try {
        exampleFunction()
        println("함수가 성공적으로 실행되었습니다.")
    } catch (e: Exception) {
        println("함수 실행 중 오류가 발생했습니다: $e")
    }
}
```

## 7. return 문을 사용하지 않는 함수를 정의할 수 있는가?
반환값이 필요 없는 함수(반환 타입이 Unit인 경우)를 정의할 때 return 문을 생략할 수 있다.

## 8. 지역 함수란 무엇인가?
특정 함수 내에 정의된 함수로, 자신을 둘러싼 함수의 변수나 함수에 접근할 수 있다.

### 이런 함수를 자바에서는 어떻게 흉내 낼 수 있을까?
지역 함수를 둘러싼 영역의 변수나 파라미터 목록 등의 문맥을 포획해주는 특별한 클래스(익명 클래스, 람다 표현식)를 선언한다. 그래서 지역 함수를 호출할 때마다 이런 특별한 객체를 생성하는 부가 비용이 든다.

## 9. 공개(public)와 비공개(private) 최상위 함수는 어떤 차이가 있는가?
최상위 함수의 디폴트는 공개 함수로서, 함수가 정의된 파일 내부뿐 아니라 프로젝트 어디에서나 쓰일 수 있다. 반면에 최상위 함수를 비공개로 정의하면 함수가 정의된 파일 안에서만 해당 함수를 볼 수 있다.

## 10. 패키지를 사용해 코드를 어떻게 여러 그룹으로 나눌 수 있는가?
맨 앞에 패키지 이름을 지정하면 파일에 있는 모든 최상위 선언(클래스, 인터페이스, 함수 등)을 지정한 패키지 내부에 넣을 수 있다.

### 자바와 코틀린 패키지의 가장 핵심적인 차이는 무엇인지 설명하라.
자바에서는 패키지 구조와 컴파일 대상 루트에 있는 소스 트리 디렉터리 구조가 같아야 한다. 둘의 경로가 다르면 컴파일 오류가 발생한다.

코틀린의 패키지 계층 구조는 소스 파일에 있는 패키지 디렉티브로부터 구성된 별도의 구조다. 즉, 소스 파일 트리와 패키지 계층 구조가 다를 수도 있다.

## 11. 임포트 별명이란 무엇인가?
임포트한 선언에 새 이름을 부여하는 것으로, 새 이름은 임포트 이렉티브가 있는 파일 전체 영역에서 유효하다. 또 다른 형태의 임포트로 어떤 영역에 속한 모든 선언을 한꺼번에 임포트할 수 있다. 전체 이름 뒤에 `*`를 붙이면 된다.

### 자바의 정적 임포트와 비슷한 임포트를 코틀린에서는 어떻게 처리하는가?
코틀린에서는 정적 임포트 구문 없이 일반적인 임포트 디렉티브 구문을 사용해 클래스의 메소드나 속성을 임포트할 수 있다.

## 12. if 문/식은 어떤 일을 하는가? 각각을 자바의 if 문 및 3항 조건 연산자(?:)와 비교해보라.
if 문/식은 불(boolean) 식의 결과에 따라 두 가지 대안 중 하나를 선택할 수 있다. 코틀린 if는 자바 if 문과 비슷한 문법을 제공하지만, 3항 연산자(조건 ? 참일 때\_식 : 거짓일 때\_식)가 없다. 대신에 if 문을 식으로 쓸 수 있다는 점이 이 단점을 대부분 상쇄해준다. if 문을 식으로 사용할 때는 양 가지가 모두 있어야 한다.

## 13. when 문을 처리하는 알고리즘을 설명하라.
when 문은 코드에 쓰여져 있는 순서대로 조건을 검사해서 맨 처음으로 참으로 평가되는 조건을 찾고, 해당 조건에 대응하는 문을 실행한다. 만약 모든 조건이 거짓이라면 else 부분을 실행한다.

### 자바 switch와 코틀린 when은 어떤 차이가 있는가?
when에서는 임의의 조건을 검사할 수 있지만 switch에서는 주어진 식의 여러 가지 값 중 하나만 선택할 수 있다. 게다가 자바의 switch 문은 폴스루(fall-through)라는 의미를 제공한다. 코틀린 when은 조건을 만족하는 가지만 실행하고 절대 폴스루를 하지 않는다.

- 폴스루 : 어떤 조건을 만족할 때 프로그램이 해당 조건에 대응하는 문을 실행하고 명시적으로 break를 만날 때까지 그 이후의 모든 가지를 실행한다.

## 14. 자바 for (int i = 0; i < 100; i++)와 같이 수를 세는 루프를 코틀린에서는 어떻게 구현하는가?
```kotlin
for (i in 0..99) or for (i in 0 until 100)
```

## 15. 코틀린이 제공하는 루프 문에는 어떤 것이 있는가?
- for, while, do-while

### while과 do...while의 차이는 무엇인가?
while은 루프 진입 전에 조건을 검사하지만, do-while은 루프 몸통을 실행한 다음에 조건을 검사하므로 루프 몸통이 최소 한 번은 실행된다.

## 16. break와 continue를 사용해 루프의 제어 흐름을 어떻게 변경할 수 있는가?
break는 즉시 루프를 종료시키고, 실행 흐름이 루프 바로 다음 문으로 이동하게 만든다.

continue는 현재 루프 이터레이션(iteration)을 마치고 조건 검사로 바로 진행하게 만든다.

## 17. 예외 처리 과정을 전체적으로 설명하라.
프로그램은 예외를 잡아내는 핸들러를 찾는다. 예외와 일치하는 핸들러가 있다면 예외 핸들러가 처리한다.
현재 함수 내부에서 핸들러를 찾을 수 없으면 함수 실행이 종료되고 함수가 스택에서 제거 된다. 그리고 호출한 쪽에서 핸들러 검색을 수행한다. 이런 경우를 호출자에게 전파했다고 말한다.
프로그램 진입접에 이를 때까지 예외를 잡아내지 못하면 현재 스레드가 종료된다.

### 자바와의 차이점은 무엇인가?
자바와 달리 코틀린에서는 클래스 인스턴스를 생성(여기서는 예외)할 때 new 같은 특별한 구문을 사용하지 않는다. 자바에서는 도착할 수 없는 코드를 금지하지만, 코틀린은 허용한다. 자바와 달리 코틀린에서는 검사 예외(checked exception)와 비검사 예외(unchecked exception)을 구분하지 않는다.

### 자바와 코틀린에서 try 문이 어떻게 다른지 설명하라.
코틀린에서는 try가 식으로 쓰일 수 있어 try 블록의 값이거나 예외를 처리한 catch 블록의 값이 된다.